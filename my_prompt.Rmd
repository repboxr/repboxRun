
Below are relevant files from my R project.

DESCRIPTION


# FILE: DESCRIPTION
```
Package: repboxRun
Type: Package
Title: Run repbox analyses
Version: 0.1
Author: Sebastian Kranz (Ulm University)
Maintainer: Sebastian Kranz <sebastian.kranz@uni-ulm.de>
Description: Run repbox analyses 
License: GPL >= 3.0
Depends: dplyr, restorepoint,repboxArt, repboxRegmap, repboxMap repboxStata, repboxReg,
         repboxDB, repboxCodeText, repboxHtml, repboxR, repboxDoc
Encoding: UTF-8
LazyData: true

```
# END OF FILE: DESCRIPTION

-----------------------------------------------------------


# R code (project repboxRun)


# FILE: expost_info.R
```
example = function() {
  parent_dir = "~/repbox/projects_static"
  parent_dir = "~/repbox/projects_gha"
  project_dirs = list.dirs(parent_dir, recursive = FALSE)
  for (project_dir in project_dirs) {
    repbox_store_project_problems(project_dir)
  }

  project_dir = first(project_dirs)
  for (project_dir in project_dirs) {
    repbox_store_step_timing(project_dir)
  }

  project_dir = project_dirs[1]
}

repbox_store_step_timing = function(project_dir, parcels=list()) {
  step_files = list.files(file.path(project_dir,"steps"), glob2rx("*.Rds"),full.names = TRUE)

  base = basename(step_files)

  time_li = lapply(step_files, function(file) {
    dat = readRDS(file)
    as.numeric(dat[[1]])
  }) %>% unlist()


  df = data.frame(
    step = str.left.of(base, "."),
    start_end = str.between(base, ".","."),
    time = time_li
  ) %>% arrange(step, start_end)



  step_timing = df %>%
    group_by(step) %>%
    summarize(
      sec = ifelse(n()==2, as.numeric(time[1])-as.numeric(time[2]), NA_real_)
    ) %>%
    mutate(artid = basename(project_dir))

  repdb_dir = file.path(project_dir,"repdb")
  parcels$step_timing = list(step_timing=step_timing)
  repdb_save_parcels(parcels["step_timing"],dir = repdb_dir)
  parcels
}

repbox_store_project_problems = function(project_dir, parcels=list()) {
  restore.point("repbox_store_project_problems")

  prob_li = vector("list",0)

  parcels = repdb_load_parcels(project_dir, "stata_do_run_info",parcels = parcels)
  info = parcels$stata_do_run_info$stata_do_run_info
  if (NROW(info)>0) {
    num = sum(info$timeout, na.rm = TRUE)
    if (num > 0) {
      prob_li[[length(prob_li)+1]] = list(type="timeout", msg = paste0(num, " do files had a timeout."))
    }
    num = sum(info$num_load_data_err, na.rm=TRUE)
    if (num > 0) {
      prob_li[[length(prob_li)+1]] = list(type="missing_data", msg = paste0(num, " data load commands did not work."))
    }
    num = sum(info$has_parse_err, na.rm=TRUE)
    if (num > 0) {
      prob_li[[length(prob_li)+1]] = list(type="parse_error", msg = paste0(num, " do files had a parse errors."))
    }
  }


  problem_dir = file.path(project_dir,"problems")
  repdb_dir = file.path(project_dir,"repdb")
  prob_files = list.files(problem_dir,full.names = TRUE)

  prob_li = c(
    prob_li,
    lapply(prob_files, readRDS)
  )
  if (length(prob_li)==0) {
    problem_rds = file.path(repdb_dir,"problem.Rds")
    if (file.exists(problem_rds)) {
      file.remove(problem_rds)
    }
    return(parcels)
  }

  prob_df = lapply(prob_li, function(x) {
    as.data.frame(x[1:2])
  }) %>%
    bind_rows()
  names(prob_df) = c("problem_type", "problem_descr")

  prob_df$artid = basename(project_dir)

  parcels$problem = list(problem=prob_df)
  repdb_save_parcels(parcels["problem"],dir = repdb_dir)
  parcels
}


repbox_store_step_info = function(project_dir) {

}

```
# END OF FILE: expost_info.R

-----------------------------------------------------------


# FILE: file_utils.R
```
remove.dir = function(dir.to.be.removed, recursive=TRUE, must.contain = "/projects") {
  if (!has.substr(dir.to.be.removed,must.contain)) {
    stop(paste0("Sorry, for security reasons currently only directories that contain the path ", must.contain, " can be removed."))
  }
  if (!dir.exists(dir.to.be.removed)) return()
  unlink(dir.to.be.removed,recursive = recursive)
}



unzip.zips = function(dir, remove=TRUE) {
  zip.files = list.files(dir, glob2rx("*.zip"), ignore.case=TRUE,full.names=TRUE,recursive = TRUE)
  for (zip.file in zip.files) {
    try(unzip(zip.file, exdir = dirname(zip.file)))
  }
  gz.files = list.files(dir, glob2rx("*.gz"), ignore.case=TRUE,full.names=TRUE,recursive = TRUE)
  for (gz.file in gz.files) {
    try(R.utils::gunzip(gz.file,remove=remove))
  }
  bz.files = list.files(dir, glob2rx("*.bz2"), ignore.case=TRUE,full.names=TRUE,recursive = TRUE)
  for (bz.file in bz.files) {
    try(R.utils::bunzip2(bz.file,remove=remove))
  }

  tar.files = list.files(dir, glob2rx("*.tar"), ignore.case=TRUE,full.names=TRUE,recursive = TRUE)
  for (tar.file in tar.files) {
    try(utils::untar(tar.file,exdir = dirname(tar.file)))
  }

}

repbox_get_org_sup_files = function(project_dir) {
  restore.point("repbox_get_org_sup_files")

  file = file.path(project_dir, "meta","sup_files.Rds")
  if (file.exists(file)) {
    file_df = readRDS(file)
    return(file_df)
  }

  if (repbox_has_just_extracted_code(project_dir)) {
    stop("The project has just extracted code files, but no general file ifo meta/sup_files.Rds exists, which should have created when project was initialized.")
  }

  file = file.path(project_dir, "repbox","org_files.Rds")
  if (file.exists(file)) {
    file_df = readRDS(file)
  } else {
    if (dir.exists(file.path(project_dir,"org"))) {
      file_df = make.project.files.info(project_dir,for.mod=FALSE)$org
    } else {
      stop("Cannot anymore generate file_df since org folder does not exist and no previous file info was stored...")
    }
  }

  file_df = file_df %>%
    transmute(
      file_path = file,
      file_type = tolower(ext),
      timestamp = mtime,
      mb = size / 1e6
    )

  return(file_df)
}

make.project.files.info = function(project_dir, for.org = TRUE, for.mod=TRUE) {
  restore.point("make.project.files.info")
  oldwd = getwd()
  org.fi = mod.fi = NULL

  if (!dir.exists(file.path(project_dir,"repbox"))) {
    dir.create(file.path(project_dir,"repbox"))
  }

  dir = file.path(project_dir,"org")
  if (for.org & dir.exists(dir)) {


    setwd(dir)
    files = list.files(dir,recursive = TRUE,include.dirs = FALSE)
    fi = as.data.frame(file.info(files))
    rownames(fi) = NULL
    fi$file = files
    fi$base = basename(files)
    fi$ext = tools::file_ext(files)
    fi
    org.fi = fi
    saveRDS(fi,file.path(project_dir,"repbox/org_files.Rds"))
  }

  dir = file.path(project_dir,"mod")
  if (for.mod & dir.exists(dir)) {
    setwd(dir)
    files = list.files(dir,recursive = TRUE,include.dirs = FALSE)
    fi = as.data.frame(file.info(files))
    rownames(fi) = NULL
    fi$file = files
    fi$base = basename(files)
    fi$ext = tools::file_ext(files)
    mod.fi = fi
    saveRDS(fi,file.path(project_dir,"repbox/mod_files.Rds"))
  }

  if (!is.null(oldwd)) setwd(oldwd)
  list(org = org.fi, mod=mod.fi)
}


repbox_make_script_parcel = function(project_dir, parcels) {
  restore.point("repbox_parcel_script")
  org.fi = parcels$.files$org

  script_df = org.fi %>%
    mutate(file_type = tolower(ext)) %>%
    filter(file_type %in% c("do","r")) %>%
    arrange(file_type, file) %>%
    mutate(
      artid=basename(project_dir),
      file_path=file,
      file_name = basename(file),
      sup_dir = paste0(project_dir, "/org"),
      long_path = paste0(sup_dir,"/", file),
      script_num = seq_len(n()),
      file_exists = file.exists(long_path),
      source_added = file_exists
    )
  text = rep(NA_character_, NROW(script_df))
  num_lines = rep(NA_integer_, NROW(script_df))

  for (i in seq_len(NROW(script_df))) {
    if (script_df$file_exists[i]) {
      txt = readLines(script_df$long_path[i],encoding = "UTF-8",warn = FALSE)
      text[i] = merge.lines(txt)
      num_lines[i] = length(txt)
    }
  }
  script_df$num_lines = num_lines

  # To avoid possible encoding errors later
  text = iconv(text,sub="?",from="UTF-8",to="UTF-8")

  script_df$text = text

  do_df = script_df %>% filter(file_type=="do")
  r_df = script_df %>% filter(file_type == "r")

  parcels = list(
    stata_file = list(script_file=do_df),
    stata_source = list(script_source = do_df),
    r_file = list(script_file = r_df),
    r_source = list(script_source = r_df)
  )
  repdb_save_parcels(parcels, dir = file.path(project_dir, "repdb") )
  return(parcels)
}

special_file_types = function() {
  unlist(list(
    code = c("do","ado","r","mod","nb","py","m", "sas","prg", "ztt","c","java","cpp","js","f95","f90", "tsp","g","lng","gms","jl","rmd"),
    data = c("dta","csv","xls","xlsx","mat","dat","sas7bdat","rdata","rds", "xml","json", "tab"),
    archive =  c("7z","gz","tar","zip")
  ))
}
```
# END OF FILE: file_utils.R

-----------------------------------------------------------


# FILE: init.R
```
#' Call this function to initialize a new repbox project
#'
#' It will generate the new project directory and fill it with the
#' neccessary files to call repbox_run_project.
#'
#' @param project_dir The directory of the new project
#' @param sup_zip The ZIP file of the supplement
#' @param pdf_files The PDF file(s) of the article. Currently only a single PDF file works but in the future also support for multiple PDF files, e.g. article plus online appendix, will be added.
#' @param html_files Alternatively, the HTML file(s) of the article.
#' @param remove_macosx_dirs If TRUE, the "__MACOSX" directories will be removed from the supplement.
#' @param just_extract_code If TRUE just the R and Stata code files of the supplement will be extracted. This can (only) make sense if you just want to perform static analysis of code (and the article). Then you can save space. Complete repbox analysis won't be feasible however.
#' @export
repbox_init_project = function(project_dir, sup_zip=NULL, pdf_files=NULL, html_files = NULL, remove_macosx_dirs=TRUE, overwrite_org = FALSE, just_extract_code = FALSE) {
  restore.point("repbox_init_project")

  project = basename(project_dir)
  org.dir = file.path(project_dir,"org")
  repbox.dir = file.path(project_dir, "repbox")

  if (!dir.exists(project_dir)) {
    dir.create(project_dir)
  }

  if (!dir.exists(file.path(project_dir,"meta"))) {
    dir.create(file.path(project_dir,"meta"))
  }

  # Set working directory.
  # Otherwise if working directory will be deleted we can get later an error:
  # sh: 0: getcwd() failed
  setwd(project_dir)

  # Copy supplement ZIP content into org.dir
  if (!is.null(sup_zip) & (overwrite_org | !(dir.exists(org.dir)))) {
    # Some reproduction packages consist of multiple zip
    # files
    for (zip_file in sup_zip) {
      repbox_sup_extract_zip(project_dir, zip_file, just_extract_code, remove_macosx_dirs=remove_macosx_dirs)
    }
  }

  if (!dir.exists(org.dir)) {
    stop("You neither provided a working ZIP file nor had your project has no existing directory with the original data and code supplement.")
  }

  # AEA supplements often are dupplicated
  # in a separate "__MACOSX" directory
  # We will remove those by default
  if (remove_macosx_dirs) {
    remove_macosx_dirs(org.dir)
  }

  # We get an error if current working directory does not exist
  repbox_copy_art_pdf(project_dir, pdf_files)
  repbox_copy_art_html(project_dir, html_files)
}

repbox_has_just_extracted_code = function(project_dir) {
  just_extract_code_file = file.path(project_dir, "steps", "NOTE_JUST_EXRACTED_CODE")
  file.exists(just_extract_code_file)
}

repbox_sup_extract_zip = function(project_dir, sup_zip, just_extract_code, remove_macosx_dirs=TRUE) {
  restore.point("repbox_sup_just_extract_code")

  org.dir = file.path(project_dir,"org")
  repbox.dir = file.path(project_dir, "repbox")
  steps.dir = file.path(project_dir, "steps")
  just_extract_code_file = file.path(steps.dir, "NOTE_JUST_EXRACTED_CODE")

  # 1. Get all files in ZIP
  file_df = unzip(sup_zip, list = TRUE)

  names(file_df) = c("file_path","mb","timestamp")
  file_df$mb = file_df$mb / 1e6
  file_df$file_type = tolower(tools::file_ext(file_df$file_path))

  if (remove_macosx_dirs) {
    ignore = has.substr(file_df$file_path, "__MACOSX")
    file_df = file_df[!ignore,]
  }

  meta_dir = file.path(project_dir, "meta")
  if (!dir.exists(meta_dir)) dir.create(meta_dir)
  saveRDS(file_df, file.path(meta_dir, "sup_files.Rds"))


  if (!just_extract_code) {
    robust_unzip(sup_zip, exdir = org.dir)
    if (file.exists(just_extract_code_file)) file.remove(just_extract_code_file)
    note_problem_if_no_sub_files(project_dir, file_df = file_df)
    return(TRUE)
  }
  # 2. Unzip R and stata scripts files
  code_files = file_df$file_path[file_df$file_type %in% c("r","do","rmd","ado")]
  if (length(code_files)>0) {
    # internal unzip more often claims that ZIP is
    # corrupted while command line unzip works
    #unzip(sup_zip,files = code_files,exdir = org.dir, unzip="unzip")
    robust_unzip(normalizePath(sup_zip), exdir=normalizePath(org.dir), files=code_files)
    note_problem_if_no_sub_files(project_dir, file_df = file_df)
  } else {
    dir.create(org.dir)
  }

  # 3. Store note that just code has been extracted
  if (!dir.exists(steps.dir)) dir.create(steps.dir, recursive = TRUE)
  writeLines("yes", just_extract_code_file)

  return(TRUE)

}


repbox_copy_art_pdf = function(project_dir, pdf_files = NULL) {
  restore.point("copy.repbox.art")
  pdf.dir = file.path(project_dir, "art", "pdf")
  if (!is.null(pdf_files)) {
    clear.and.create.dir(pdf.dir)
    file.copy(pdf_files, pdf.dir,recursive = TRUE)
  }
}

repbox_copy_art_html = function(project_dir, html_files = NULL) {
  restore.point("repbox_copy_art_html")
  html.dir = file.path(project_dir, "art", "html")
  if (!is.null(html_files)) {
    clear.and.create.dir(html.dir)
    file.copy(html_files, html.dir,recursive = TRUE)
  }
}


remove_macosx_dirs = function(parent.dir) {
  dirs = list.dirs(parent.dir)
  mac.dirs = dirs[has.substr(dirs, "__MACOSX")]
  for (mac.dir in mac.dirs) {
    remove.dir(mac.dir,recursive = TRUE)
  }
}

# R's internal unzip command too often thinks the ZIP file of a replication package
# is corrupted even though linux command line unzip is able to unzip it.
robust_unzip = function(zipfile, exdir, files=NULL, overwrite=TRUE, verbose=FALSE) {
  restore.point("robust_unzip")
  if (overwrite) {
    cmd = paste0("unzip -o ")
  } else {
    cmd = paste0("unzip -n ")
  }

  if (is.null(files)) {
    cmd = paste0(cmd, '"', normalizePath(zipfile), '" -d "', normalizePath(exdir,mustWork = FALSE),'"')
  } else {
    cmd = paste0(cmd,'"', normalizePath(zipfile), '" ', paste0('"',files,'"', collapse=" "), ' -d "', normalizePath(exdir,mustWork = FALSE),'"')

  }
  cat(cmd)
  system(cmd,ignore.stdout = !verbose)
  #rstudioapi::filesPaneNavigate(exdir)
}


note_problem_if_no_sub_files = function(project_dir, sup_dir=paste0(project_dir, "/org"),file_df) {
  restore.point("note_problem_if_no_sub_files")
  if (!missing(file_df)) {
    if (NROW(file_df)==0) return()
  }
  files = list.files(sup_dir)
  if (length(files)==0) {
    repboxUtils::repbox_problem(type="zip_no_files", msg="We could not extract any files from the ZIP of the reproduction package. Possibly corrupted.",fail_action = "msg",project_dir = project_dir)
  }
}


```
# END OF FILE: init.R

-----------------------------------------------------------


# FILE: repboxRun.R
```
example = function() {

  library(repboxRun)
  library(repboxEJD)
  #artid = "ecta_84_2_6"
  artid = ""
  #rstudioapi::filesPaneNavigate(paste0("~/repbox/projects_gha/",artid))

  artid = "aejmic_17_2_2"
  projects.dir = "~/repbox/projects_test"

  #artid = "testsupp"
  repbox_init_ejd_project(artid=artid, projects.dir=projects.dir)

  Project_dir = file.path(projects.dir,artid)
  steps = repbox_steps_from(file_info = TRUE)
  #steps = repbox_steps_from(reproduction = TRUE, map=TRUE, html = TRUE)
  #steps = repbox_steps_from(mr_base = TRUE)
  #steps = repbox_steps_from(html=TRUE)
  html_opts = repbox_html_opts(make_what = c("ejd","general"))
  #stata_opts = repbox_stata_opts(timeout = 5*60, rerun.failed.included.do = FALSE)
  #opts = repbox_run_opts(stop.on.error = FALSE,html_opts=html_opts)
  #steps = repbox_steps_from(map = TRUE,html=FALSE)
  #steps = repbox_steps_from(file_info = TRUE,art = TRUE,reproduction = FALSE)
  options(warn=1)
  opts = repbox_run_opts(stop.on.error = !TRUE,timeout = 10*60, art_opts = repbox_art_opts(overwrite=TRUE), html_opts = html_opts)
  repbox_run_project(Project_dir,lang="stata", steps=steps, opts=opts)
  rstudioapi::filesPaneNavigate(Project_dir)
  rstudioapi::filesPaneNavigate(paste0("~/repbox/projects_gha/",artid))

  #repboxExplore::make_reg_playground(project_dir, steps = 16)

  steps = repbox_steps_from(html = TRUE)
  html_opts = repboxHtml::repbox_html_opts_just_ejd()
  repbox_run_project(project_dir,lang="stata", steps=steps, opts=repbox_run_opts(html_opts = html_opts))


  library(repboxRun)
  project_dir = "/home/rstudio/repbox/projects_test/testsupp"
  options(warn=1)
  restore.point.options(display.restore.point = !TRUE)
  html_opts = repboxHtml::repbox_html_opts_just_ejd()
  opts = repbox_run_opts(stop.on.error = FALSE, timeout = 10, html_opts = html_opts)
  steps = repbox_steps_from(file_info = TRUE,static_code=TRUE, art=FALSE, reproduction = TRUE,reg = TRUE,mr_base = TRUE,map = FALSE,html = TRUE)
  repbox_run_project(project_dir, steps=steps, opts=opts)

  rstudioapi::filesPaneNavigate(project_dir)

  #dap = readRDS(file.path(project_dir, "metareg/dap/stata/dap.Rds"))
  #plot.dap(dap)

  library(repboxRun)
  project_dir = "/home/rstudio/repbox/projects_reg/aejmac_6_3_1"
  project_dir = "/home/rstudio/repbox/projects_reg/testsupp"
  project_dir = "/home/rstudio/repbox/projects_reg/aejpol_3_4_8"
  project_dir = "/home/rstudio/repbox/projects_reg/aejpol_7_2_11"

  #steps = repbox_run_steps_from(art = TRUE)
  #restorepoint::restore.point.options(display.restore.point = !TRUE)
  steps = repbox_run_steps_from(reproduction =  TRUE,map=TRUE)
  opts = repbox_run_opts(art_opts = repbox_art_opts(overwrite=TRUE), html_opts = repbox_html_opts(add_art_source_tab = TRUE))
  repbox_run_project(project_dir, steps=steps, opts=opts)

  rstudioapi::filesPaneNavigate(project_dir)

}

#' @title Run repbox analysis for a project (article with supplement)
#'
#' @param project_dir Path to project directory
#' @param lang Language(s) to run analysis for can be any subset of c("r","stata")
#' @param steps Vector of analysis steps to run. Use repbox_steps_from function to create this.
#' @param opts Options for analysis steps generated by repbox_run_opts function.
#' @export
repbox_run_project = function(project_dir, lang = c("stata","r"), steps = repbox_steps_all(), opts = repbox_run_opts()) {
  restore.point("repbox_run_project")
  options(dplyr.summarise.inform = FALSE)

  if (!dir.exists(project_dir)) {
    cat("\nProject directory", project_dir, "does not exist!\n")
    return(invisible(FALSE))
  }
  repbox_set_problem_options(project_dir=project_dir, fail_action=opts$problem_fail_action)
  repbox_set_current_project_dir(project_dir)
  dap.file = paste0(project_dir,"/metareg/dap/stata/dap.Rds")

  show_title = function(str) {
    cat("\n++++++++++++++++++++++++++++++++++++++++++++++++++++\n",str,"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
  }

  org.dir = file.path(project_dir,"org")
  sup.dir = file.path(project_dir,"mod")
  repbox.dir = file.path(project_dir, "repbox")
  repbox.stata.dir = file.path(project_dir, "repbox/stata")
  repbox.r.dir = file.path(project_dir, "repbox/r")

  # Delete existing problems directory
  problems.dir = file.path(project_dir, "problems")
  if (opts$remove_existing_problems) {
    remove.dir(problems.dir, must.contain = project_dir)
  }


  artid = basename(project_dir)

  parcels = list(.files = list())


  if (steps$file_info) {
    show_title("Extract supplement's basic file information")
    repbox_log_step_start(project_dir, "file_info", opts=NULL)
    parcels = sup_save_basic_info(project_dir, parcels)

    # Also save article basic info
    repboxArt::art_save_basic_info(project_dir)

    repbox_log_step_end(project_dir, "file_info")
  }

  parcels = repdb_load_parcels(project_dir,"sup", parcels)
  sup_info = parcels$sup$sup
  if (!is.null(sup_info)) {
    if (isTRUE(!sup_info$has_r) & "r" %in% lang) {
      cat("\nNo R scripts found...\n")
      lang = setdiff(lang, "r")
    }
    if (isTRUE(!sup_info$has_stata) & "stata" %in% lang) {
      cat("\nNo Stata do scripts found...\n")
      lang = setdiff(lang, "stata")
    }
  }

  if (steps$static_code) {
    show_title("Static analysis of code and its comments")
    repbox_log_step_start(project_dir, "static_code", opts)

    if (!dir.exists(repbox.dir)) dir.create(repbox.dir)

    # Create file info from /org folder
    parcels$.files$org = make.project.files.info(project_dir,for.org=TRUE, for.mod = FALSE)$org
    # Save script content in Rds files in parcels
    if (opts$make_script_parcel) {
      parcels = repbox_make_script_parcel(project_dir, parcels)
    }
    if ("stata" %in% lang) {
      cat("\n  Stata static code analysis...\n\n")
      parcels = repbox_stata_static_parcel(project_dir, parcels=parcels, opts=opts)
      parcels = repboxCodeText::code_project_find_refs(project_dir, parcels=parcels)
    }
    if ("r" %in% lang) {
      cat("\n  R static code analysis...\n\n")
      parcels = repboxR::repbox_project_static_analyse_r(project_dir,parcels=parcels, opts=opts$r_opts)
    }

    repbox_log_step_end(project_dir, "static_code")
  }


  if (steps$art) {
    show_title("Extract information from article text")
    repbox_log_step_start(project_dir, "art", opts)
    art_update_project(project_dir, opts=opts$art_opts)
    repbox_log_step_end(project_dir, "art")
  }

  # If we run the reproduction step again, we will clear most results
  if (steps$reproduction) {
    show_title("Reproduction of initial supplement")
    repbox_log_step_start(project_dir, "reproduction", opts)

    if (dir.exists(sup.dir)) remove.dir(sup.dir,must.contain = project_dir)

    # Keep file dates so that we can better
    # see which files are overwritten when comparing
    # original to modified supplement
    copy.dir(org.dir, sup.dir,copy.date=TRUE)
    unzip.zips(sup.dir)
    make.project.files.info(project_dir, for.mod = TRUE, for.org=TRUE)

    # Remove all files except for code files in org folder
    if (opts$slimify_org) {
      slimify.org.dir(project_dir)
    }


    if ("stata" %in% lang) {
      remove.dir(repbox.stata.dir,must.contain = project_dir)
      dir.create(repbox.stata.dir)

      dap_and_cache_remove_from_project(project_dir)
      res = repbox_project_run_stata(project_dir,opts=opts$stata_opts)
      parcels = repbox_save_stata_run_parcels(project_dir, parcels)
      parcels = make_parcel_stata_do_run_info(project_dir, parcels)
    }
    if ("r" %in% lang) {
      parcels = repbox_project_run_r(project_dir, opts=opts$r_opts,parcels = parcels)
      parcels = repbox_project_extract_r_results(project_dir, parcels, opts=opts$r_opts)
    }
    make.project.files.info(project_dir, for.mod = TRUE, for.org=FALSE)
    repbox_log_step_end(project_dir, "reproduction")
  }

  parcels = repdb_load_parcels(project_dir, "stata_run_info", parcels=parcels)
  has_stata_regs = isTRUE(parcels$stata_run_info$stata_run_info$reg_runs > 0)
  has_ok_stata_regs = isTRUE(parcels$stata_run_info$stata_run_info$ok_reg_runs > 0)


  if (steps$reg & "stata" %in% lang & has_ok_stata_regs) {
    show_title("Rerun Stata scripts to extract regression information")
    repbox_log_step_start(project_dir, "reg", opts)

    dap = get.project.dap(project_dir, make.if.missing = TRUE)

    if (opts$store_data_caches) {
      cache.dir = file.path(project_dir, "metareg/dap/stata/cache")
      if (!dir.exists(cache.dir)) dir.create(cache.dir,recursive = TRUE)
      store.data = dap.to.store.data(dap, cache.dir)
    } else {
      store.data = NULL
    }

    if (dir.exists(sup.dir)) remove.dir(sup.dir,must.contain = project_dir)
    copy.dir(org.dir, sup.dir,copy.date=TRUE)
    unzip.zips(sup.dir)

    stata_opts = opts$stata_opts
    stata_opts$extract.reg.info = TRUE
    stata_opts$extract.scalar.vals = TRUE
    stata_opts$store.data = store.data
    parcels = repbox_project_run_stata(project_dir,opts=stata_opts, parcels=parcels)
    parcels = repbox_save_stata_reg_run_parcels(project_dir, parcels)
    #restore.point("hfjhfksf")
    res = dap_create_stata_scalar_info(project_dir = project_dir, dap=dap, scalar_df = parcels$stata_scalar$stata_scalar)
    repbox_log_step_end(project_dir, "reg")
  } else if (steps$reg & "stata" %in% lang & !has_stata_regs) {
    show_title("Rerun Stata scripts to extract regression information")
    cat("\n  No Stata regression command was originally run.\n")
  } else if (steps$reg & "stata" %in% lang & !has_ok_stata_regs) {
    show_title("Rerun Stata scripts to extract regression information")
    cat("\n  No Stata regression command was originally run without error.\n")
  }


  if (steps$mr_base & "stata" %in% lang & has_ok_stata_regs) {
    show_title("Base Metareg")
    repbox_log_step_start(project_dir, "mr_base", opts)
    res = mr_base_run_study(project_dir, stop.on.error = opts$stop.on.error,create.repdb = TRUE,stata_version = opts$stata_version)
    repbox_log_step_end(project_dir, "mr_base")
  }

  parcels = NULL
  if (steps$repbox_repdb) {
    show_title("Store repbox repdb")
    repbox_log_step_start(project_dir, "repbox_repdb", opts)
    parcels = repbox_to_repdb(project_dir, parcels)
    repbox_log_step_end(project_dir, "repbox_repdb")
  }

  if (steps$map) {
    show_title("Create Mappings")
    repbox_log_step_start(project_dir, "map", opts)
    parcels = repboxMap::map_repbox_project(project_dir,parcels = parcels, opts = opts$map_opts)
    repbox_log_step_end(project_dir, "map")
  }

  if (steps$html) {
    show_title("Create HTML Reports")
    repbox_log_step_start(project_dir, "html", opts)
    repboxHtml::repbox_project_html(project_dir,lang=lang,parcels = parcels, opts = opts$html_opts)
    repbox_log_step_end(project_dir, "html")
  }
  return(TRUE)
}

repbox_log_step_start = function(project_dir, step, opts) {
  step.info.dir = file.path(project_dir,"steps")
  if (!dir.exists(step.info.dir)) dir.create(step.info.dir, recursive = TRUE)
  file = paste0(step.info.dir, "/",step,".start.Rds")
  saveRDS(list(start_time=Sys.time(), opts=opts), file)
}

repbox_log_step_end = function(project_dir, step) {
  step.info.dir = file.path(project_dir,"steps")
  file = paste0(step.info.dir, "/",step,".end.Rds")
  saveRDS(list(end_time = Sys.time()), file)
}


example_update_step = function() {
  library(repboxRun)
  library(repboxEJD)

  project_dirs = list.dirs("~/repbox/projects_gha",recursive = FALSE, full.names = TRUE)

  which(endsWith(project_dirs,"aer_108_6_7"))
  project_dirs = project_dirs[-c(1:291)]
  project_dir = project_dirs[1]
  for (project_dir in project_dirs) {
    cat("\n", project_dir,"\n")
    steps = repbox_steps_from(map = TRUE,html=FALSE)
    opts = repbox_run_opts(stop.on.error = !TRUE,timeout = 5*60, art_opts = repbox_art_opts(overwrite=TRUE))

    cat("\nFind table refereences in code...")
    library(repboxCodeText)
    res = code_project_find_refs(project_dir = project_dir, parcels=NULL)

    repbox_run_project(project_dir,lang="stata", steps=steps, opts=opts)
  }
  rstudioapi::filesPaneNavigate(project_dir)
}
```
# END OF FILE: repboxRun.R

-----------------------------------------------------------


# FILE: restore_scripts.R
```
# Restores scripts stored in repdb in case the org folder is deleted
# Allows to re-run static code analysis in case parsing has been changeds

example = function() {
  project_dir = "~/repbox/projects_gha/aejapp_1_1_3"
  repbox_restore_scripts(project_dir)
}

repbox_restore_scripts = function(project_dir, overwrite=FALSE) {
  parcels = repdb_load_parcels(project_dir, "stata_source")
  script_df = parcels$stata_source$script_source
  if (is.null(script_df) | NROW(script_df)==0) return(NULL)
  org_dir = file.path(project_dir, "org")
  i = 1
  for (i in seq_len(NROW(script_df))) {
    file = file.path(org_dir, script_df$file_path[i])
    dir = dirname(file)
    if (!dir.exists(dir)) dir.create(dir, recursive = TRUE)
    if (!overwrite) {
      if (file.exists(file)) next
    }
    write_utf8(script_df$text[[i]], file)
  }
}
```
# END OF FILE: restore_scripts.R

-----------------------------------------------------------


# FILE: run_opts.R
```
#' Returns all steps of a repbox analysis
#'
#' Can be used as argument steps in repbox_run_project
repbox_steps_all = function() {
  repbox_steps_from(TRUE)
}

#' Returns steps of a repbox analysis specified by starting or ending steps
#'
#' Can be used as argument steps in repbox_run_project
#'
#' The arguments of this function are the diffent possible steps in a repbox analysis
repbox_steps_from = function(file_info = FALSE, static_code=file_info, art=static_code, reproduction=art, reg=reproduction, mr_base=reg, repbox_repdb = mr_base, map=repbox_repdb, html=map) {
  list(file_info = file_info, static_code = static_code, art=art, reproduction=reproduction, reg=reg, mr_base=mr_base,repbox_repdb = repbox_repdb, map=map, html=html)
}

#' Specify options for repbox analysis
#'
#' @export
repbox_run_opts = function(stop.on.error = TRUE, stata_version = 17, slimify = FALSE, slimify_org=slimify, store_data_caches=TRUE, timeout = 60*5, remove_existing_problems=TRUE, make_script_parcel=TRUE, stata_opts = repbox_stata_opts(timeout = timeout,all.do.timeout = timeout),r_opts = repbox_r_opts(), art_opts = repbox_art_opts(), map_opts=repbox_map_opts(), html_opts = repbox_html_opts(), problem_fail_action= if(stop.on.error) "error" else "msg") {
  list(
    stop.on.error = stop.on.error,
    problem_fail_action = problem_fail_action,
    stata_version = stata_version,
    timeout = timeout,
    store_data_caches = store_data_caches,
    slimify = slimify,
    slimify_org = slimify,
    remove_existing_problems = remove_existing_problems,
    make_script_parcel = make_script_parcel,
    stata_opts = stata_opts,
    r_opts = r_opts,
    art_opts = art_opts,
    map_opts = map_opts,
    html_opts = html_opts
  )
}
```
# END OF FILE: run_opts.R

-----------------------------------------------------------


# FILE: slimify.R
```
example = function() {

  project.dirs = list.files("~/repbox/projects_ejd",recursive = FALSE,full.names = TRUE)
  projects = basename(project.dirs)

  # Just slimify projects that are already in DB
  db = get.repbox.ejd.db()
  db.df = dbGet(db, "project")
  db.projects = db.df$project
  keep = projects %in% db.projects
  project.dirs = project.dirs[keep]


  slim.df = bind_rows(lapply(project.dirs,function(project_dir) {
    res = NULL
    try(res <- slimify.solved.project(project_dir, force=FALSE))
    res
  }))
  saveRDS(slim.df, "~/repbox/slimify_results.Rds")

  project_dir = "~/repbox/projects_ejd/ecta_85_3_4"
  rstudioapi::filesPaneNavigate(paste0(project_dir,"/repbox"))
  res = slimify.solved.project(project_dir, force=TRUE)
}

check.size = function(project_dir) {
  all.files = list.files(project_dir,recursive=TRUE, full.names=TRUE)
  fi = file.info(all.files)
  fi$mb = fi$size / 1e6
  fi$file = all.files
  fi$ext = tools::file_ext(fi$file)
  fi = arrange(fi, desc(mb))
  fi$file[1]
}


slimify.solved.project = function(project_dir, max.org.mb = 10, max.log.mb = 1, max.stata.res.mb = 40, max.matching.mb = 10, max.cmd.mb = 0, force=FALSE, keep.org.code = FALSE) {
  restore.point("slimify.solved.project")
  slim.file = file.path(project_dir,"repbox/slimify.Rds")
  if (file.exists(slim.file)) {
    slimify = readRDS(slim.file)
    if (!force) return(slimify)
    had.old = TRUE
  } else {
    had.old = FALSE
  }
  cat("\nslimify ", project_dir)

  all.files = list.files(project_dir,recursive=TRUE, full.names=TRUE)
  all.files = enc2utf8(all.files)
  fi = file.info(all.files)
  fi$mb = fi$size / 1e6
  fi$file = all.files
  fi$ext = tools::file_ext(fi$file)

  project_dir = normalizePath(project_dir, mustWork=FALSE)
  org.fi = filter(fi, startsWith(file, file.path(project_dir,"org")))
  mod.fi = filter(fi, startsWith(file, file.path(project_dir,"mod")))
  repbox.fi = filter(fi, startsWith(file, file.path(project_dir,"repbox")))
  log.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/logs")))
  stata.res.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/repbox_results.Rds")))
  matching.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/matched_tabs.Rds")))
  cmd.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/cmd")))


  pre.mb = sum(fi$mb, na.rm=TRUE)
  mod.mb = sum(mod.fi$mb, na.rm=TRUE)
  org.mb = sum(org.fi$mb, na.rm=TRUE)
  repbox.mb = sum(repbox.fi$mb, na.rm=TRUE)
  log.mb = sum(log.fi$mb, na.rm=TRUE)
  stata.res.mb = sum(stata.res.fi$mb, na.rm=TRUE)
  matching.mb = sum(matching.fi$mb, na.rm=TRUE)
  cmd.mb = sum(cmd.fi$mb, na.rm=TRUE)

  # Remove mod folder including do files
  remove.dir(file.path(project_dir, "mod"))
  #non.do.files = filter(mod.fi,ext!="do")$file
  #file.remove(non.do.files)

  # Remove org folder
  slimify.org = org.mb > max.org.mb
  if (slimify.org) {
    if (!keep.org.code) {
      remove.dir(file.path(project_dir, "org"))
    } else {
      non.code.files = filter(org.fi,! tolower(ext) %in% c("do","r","py","m","rmd","ado","jl"))$file
      file.remove(non.code.files)
    }
  }

  slimify.log = log.mb > max.log.mb
  if (slimify.log) {
    file.remove(log.fi$file)
  }

  slimify.stata.res = stata.res.mb > max.stata.res.mb
  if (slimify.stata.res) {
    file.remove(stata.res.fi$file)
  }

  slimify.matching = matching.mb > max.matching.mb
  if (slimify.matching) {
    file.remove(matching.fi$file)
  }

  slimify.cmd = cmd.mb > max.cmd.mb
  if (slimify.cmd) {
    file.remove(cmd.fi$file)
  }


  post.files = list.files(project_dir,recursive=TRUE, full.names=TRUE)
  post.files = enc2utf8(post.files)
  post.fi = filter(fi, file %in% post.files)
  post.mb = sum(post.fi$mb, na.rm=TRUE)

  if (!had.old) {
    slimify = tibble(project=basename(project_dir),pre.mb,post.mb,slimify.org, slimify.log, slimify.stata.res, slimify.matching, slimify.cmd,  mod.mb, org.mb, repbox.mb, log.mb, stata.res.mb,matching.mb, cmd.mb, max.org.mb, max.log.mb, max.stata.res.mb, max.matching.mb, max.cmd.mb, kept.org.code = keep.org.code | !slimify.org, project_dir=project_dir,timestamp = Sys.time())
  } else {
    slimify$post.mb = post.mb
    slimify$slimify.log = slimify.log | slimify$slimify.log
    slimify$slimify.org = slimify.org | slimify$slimify.org
    slimify$slimify.stata.res = slimify.stata.res | slimify$slimify.stata.res
    slimify$slimify.matching = slimify.matching | slimify$slimify.matching
    slimify$slimify.cmd = slimify.log | isTRUE(slimify$slimify.cmd)
    slimify$max.log.mb = min(c(slimify$max.log.mb, max.log.mb))
    slimify$max.org.mb = min(c(slimify$max.org.mb, max.org.mb))
    slimify$max.stata.res.mb = min(c(slimify$max.stata.res.mb, max.stata.res.mb))
    slimify$max.matching.mb = min(c(slimify$max.matching.mb, max.matching.mb))
    slimify$max.cmd.mb = min(c(slimify$max.cmd.mb, max.cmd.mb))
    slimify$kept.org.code = keep.org.code | !slimify.org
    slimify$timestamp = Sys.time()
  }

  cat(paste0(" from ", round(pre.mb,3), " MB to ", round(post.mb,3)," MB.\n"))

  saveRDS(slimify, file.path(project_dir,"repbox","slimify.Rds"))
  return(slimify)
}



slimify.org.dir = function(project_dir,  keep.org.code = TRUE) {
  restore.point("slimify.org.dir")
  cat("\nSlimify", file.path(project_dir,"org"))

  all.files = list.files(file.path(project_dir,"org"),recursive=TRUE, full.names=TRUE)
  all.files = enc2utf8(all.files)
  fi = file.info(all.files)
  fi$mb = fi$size / 1e6
  fi$file = all.files
  fi$ext = tools::file_ext(fi$file)

  pre.mb = sum(fi$mb, na.rm=TRUE)
  org.fi = fi

  # Remove org folder
  if (!keep.org.code) {
    remove.dir(file.path(project_dir, "org"))
  } else {
    non.code.files = filter(org.fi,! tolower(ext) %in% c("do","r","py","m","rmd","ado","jl"))$file
    file.remove(non.code.files)
  }

  post.files = list.files(file.path(project_dir,"org"),recursive=TRUE, full.names=TRUE)
  post.files = enc2utf8(post.files)
  post.fi = filter(fi, file %in% post.files)
  post.mb = sum(post.fi$mb, na.rm=TRUE)
  cat(paste0(" from ", round(pre.mb,3), " MB to ", round(post.mb,3)," MB.\n"))
  return(TRUE)
}


example.size.info = function() {
  project.dirs = readLines("~/repbox/jobs/project_dirs_use.txt")
  sizes = bind_rows(lapply(project.dirs, project.size.info))
}


project.size.info = function(project_dir) {
  restore.point("project.size.info")
  all.files = list.files(project_dir,recursive=TRUE, full.names=TRUE)
  all.files = enc2utf8(all.files)
  fi = file.info(all.files)
  fi$mb = fi$size / 1e6
  fi$file = all.files
  fi$ext = tools::file_ext(fi$file)

  project_dir = normalizePath(project_dir, mustWork=FALSE)
  org.fi = filter(fi, startsWith(file, file.path(project_dir,"org")))
  mod.fi = filter(fi, startsWith(file, file.path(project_dir,"mod")))
  repbox.fi = filter(fi, startsWith(file, file.path(project_dir,"repbox")))
  log.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/logs")))
  stata.res.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/repbox_results.Rds")))
  matching.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/matched_tabs.Rds")))
  cmd.fi = filter(repbox.fi, startsWith(file, file.path(project_dir,"repbox/stata/cmd")))


  total.mb = sum(fi$mb, na.rm=TRUE)
  mod.mb = sum(mod.fi$mb, na.rm=TRUE)
  org.mb = sum(org.fi$mb, na.rm=TRUE)
  repbox.mb = sum(repbox.fi$mb, na.rm=TRUE)
  log.mb = sum(log.fi$mb, na.rm=TRUE)
  stata.res.mb = sum(stata.res.fi$mb, na.rm=TRUE)
  matching.mb = sum(matching.fi$mb, na.rm=TRUE)
  cmd.mb = sum(cmd.fi$mb, na.rm=TRUE)

  cat("\n", project_dir, " log.mb ", round(log.mb,2), " total.mb ", round(total.mb,2))
  info = tibble(project=basename(project_dir),total.mb,log.mb, cmd.mb,  mod.mb, org.mb, repbox.mb, stata.res.mb,matching.mb, project_dir=project_dir,timestamp = Sys.time())
  return(info)
}
```
# END OF FILE: slimify.R

-----------------------------------------------------------


# FILE: sup_info.R
```
sup_save_basic_info = function(project_dir, parcels=list()) {
  restore.point("sup_save_basic_info")

  artid = basename(project_dir)

  # 1. Store info about all files
  file_df = repbox_get_org_sup_files(project_dir)

  file_info = file_df %>%
    mutate(artid = artid)

  # 2. Specific info for common file types
  file_type_info = file_info %>%
    filter(file_type %in% special_file_types()) %>%
    group_by(file_type) %>%
    summarize(
      artid = first(artid),
      num_files = n(),
      mb = sum(mb, na.rm=TRUE),
      latest_timestamp = suppressWarnings(max(timestamp))
    )


  # 3. Overview info over supplement
  meta_file = file.path(project_dir, "meta", "sup_meta.Rds")
  if (!file.exists(meta_file)) {
    sup = list()
  } else {
    sup = readRDS(meta_file)
  }
  sup = set_missing_fields(
    sup,
    artid = artid,
    license_type = NA,
    has_license_file = NA,
    sup_version = NA,
    sup_url = NA,
    sup_doi = NA,
    sup_repo = NA
  )
  sup$has_r = any(file_type_info$file_type=="r")
  sup$has_stata = any(file_type_info$file_type=="do")
  sup$mb = sum(file_info$mb)
  sup$latest_timestamp = max(file_info$timestamp)

  sup = as_tibble(sup)

  parcels$sup = list(sup=sup)
  parcels$file_info = list(file_info=file_info)
  parcels$file_type_info = list(file_type_info=file_type_info)
  repboxDB::repdb_save_parcels(parcels[c("sup", "file_info","file_type_info")], file.path(project_dir, "repdb"))

  parcels
}
```
# END OF FILE: sup_info.R

-----------------------------------------------------------


# Github links to related packages that are loaded

# General overview of repbox project
https://github.com/repboxr

# This package (Github link also includes some files not shown above)
https://github.com/repboxr/repboxRun

# Run Stata code and store log info
https://github.com/repboxr/repboxStata

# Static code analysis of Stata code
https://github.com/repboxr/repboxCodeText

# Rerun Stata code and store systematic regression results
# in a a format for meta studies
https://github.com/repboxr/repboxReg
# Newer version in particular for meta studies some overlap with repboxReg
https://github.com/repboxr/metaregTools

# Analysis of reproduction packages that have R code (very preliminary)
https://github.com/repboxr/repboxR


https://github.com/repboxr/repboxReadme

# Utility packages
https://github.com/repboxr/repboxUtils
https://github.com/repboxr/repboxDB


# Making reports from repbox results
https://github.com/repboxr/repboxHtml # old
https://github.com/repboxr/repboxReport # new

# Parsing information from article / appendix
https://github.com/repboxr/repboxArt # old
https://github.com/repboxr/repboxDoc # new

# Mapping regressions between code and article
https://github.com/repboxr/repboxMap # old

https://github.com/repboxr/repboxAI # new AI approach
https://github.com/repboxr/repboxRegmap # new complement to repboxAI

# Tools to systematically deal with noisy information in form of tables
# extracted from AI runs
https://github.com/skranz/FuzzyProduction


# There can be other packages under

https://github.com/repboxr/

or

https://github.com/skranz/

that are also used.



##################################
# Your Task
##################################

My repbox project is meanwhile fairly complex and older packages that will be deprecated and newer approaches currently coexist. The repboxRun package shall be the main entry point. I want to define different analysis steps that can be run for each project.

Scan the repboxRun code and the other packages with Github link above. Give an overview, of the overall state of the repbox project. What do packages do? What is already included and up-to-date in repboxRun? What should be changed?
 



